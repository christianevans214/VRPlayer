<html>
	<head>
		<style>
			body{
				margin: 0;
			}
			canvas{
				width: 100%;
				height: 100%
			}
		</style>
		<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
		<script src="./VRPlayer.js"></script>
		
	</head>
	<body>
        <video id="myVideo" width="400" controls>
            <source src="./vr-test.mp4" type="video/mp4">
        </video>
		<script>

			var manualControl = false;
			var longitude = 0;
			var latitude = 0;
			var savedX;
			var savedY;
			var savedLongitude;
			var savedLatitude;
			var srcWidth = 960;
			var srcHeight = 480;
			var width = 400;
			var height = 230;
			
			// // panoramas background
			// var panoramasArray = ["01.jpg","02.jpg","03.jpg","04.jpg","05.jpg","06.jpg"];
			// var panoramaNumber = Math.floor(Math.random()*panoramasArray.length);
			
			// // var video = document.createElement('video');
			// // 	video.src = "./vr-test.mp4";
			// // 	video.load();
			// // 	video.play();
			// var video = document.getElementById('myVideo');
			// //make your video canvas
			// var videocanvas = document.createElement('canvas');
			// var videocanvasctx = videocanvas.getContext('2d');

			// //set its size
			// videocanvas.width = srcWidth;
			// videocanvas.height = srcHeight;

			// //draw a black rectangle so that your spheres don't start out transparent
			// videocanvasctx.fillStyle = "#000000";
			// videocanvasctx.fillRect(0,0,srcWidth,srcHeight);

			// // setting up the renderer
			// renderer = new THREE.WebGLRenderer();
			// renderer.setSize(width, height);
			
			// // creating a new scene
			// var scene = new THREE.Scene();
			
			// // adding a camera
			// var camera = new THREE.PerspectiveCamera(75, width / height, 1, 1000);
			// camera.target = new THREE.Vector3(0, 0, 0);

			// // creation of a big sphere geometry
			// var sphere = new THREE.SphereGeometry(100, 100, 40);
			// sphere.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));

			// // creation of the sphere material
			// var sphereMaterial = new THREE.MeshBasicMaterial();
			// var videoTexture = new THREE.Texture(videocanvas);
			// sphereMaterial.map = videoTexture

			// // geometry + material = mesh (actual object)
			// var sphereMesh = new THREE.Mesh(sphere, sphereMaterial);
			// scene.add(sphereMesh);

			// // listeners
			// document.body.appendChild(renderer.domElement);
			// renderer.domElement.addEventListener("mousedown", onDocumentMouseDown, false);
			// renderer.domElement.addEventListener("mousemove", onDocumentMouseMove, false);
			// renderer.domElement.addEventListener("mouseup", onDocumentMouseUp, false);
				
            // render();
               
            // function render(){
				
			// 	requestAnimationFrame(render);
				
			// 	// if(!manualControl){
			// 	// 	longitude += 0.1;
			// 	// }

			// 	if ( video.readyState === video.HAVE_ENOUGH_DATA ) 
			// 	{
			// 		videocanvasctx.drawImage( video, 0, 0 );
			// 		// controls.update();
			// 		// camera.rotateY(.0030);
			// 		if ( videoTexture ) 
			// 			videoTexture.needsUpdate = true;
			// 			// controls.update();
			// 	}
			// 	// limiting latitude from -85 to 85 (cannot point to the sky or under your feet)
            //     latitude = Math.max(-85, Math.min(85, latitude));

			// 	// moving the camera according to current latitude (vertical movement) and longitude (horizontal movement)
			// 	camera.target.x = 500 * Math.sin(THREE.Math.degToRad(90 - latitude)) * Math.cos(THREE.Math.degToRad(longitude));
			// 	camera.target.y = 500 * Math.cos(THREE.Math.degToRad(90 - latitude));
			// 	camera.target.z = 500 * Math.sin(THREE.Math.degToRad(90 - latitude)) * Math.sin(THREE.Math.degToRad(longitude));
			// 	camera.lookAt(camera.target);

			// 	// calling again render function
			// 	renderer.render(scene, camera);
				
			// }
			
			window.vr_player = new VRPlayer({
				parent: document.body,
				video_id: 'myVideo',
				height: height,
				width: width,
				src_height: srcHeight,
				src_width: srcWidth,
			})
			// when the mouse is pressed, we switch to manual control and save current coordinates
			function onDocumentMouseDown(event){

				event.preventDefault();

				manualControl = true;

				savedX = event.clientX;
				savedY = event.clientY;

				savedLongitude = longitude;
				savedLatitude = latitude;

			}

			// when the mouse moves, if in manual contro we adjust coordinates
			function onDocumentMouseMove(event){

				if(manualControl){
					longitude = (savedX - event.clientX) * 0.2 + savedLongitude;
					latitude = (event.clientY - savedY) * 0.1 + savedLatitude;
				}

			}

			// when the mouse is released, we turn manual control off
			function onDocumentMouseUp(event){

				manualControl = false;

			}
			
			// // pressing a key (actually releasing it) changes the texture map
			// document.onkeyup = function(event){
			
			// 	panoramaNumber = (panoramaNumber + 1) % panoramasArray.length
			// 	sphereMaterial.map = THREE.ImageUtils.loadTexture(panoramasArray[panoramaNumber])
			
    		// 	}
			
		</script>
	</body>
</html>